/**
 * @file sltha.c
 * @date 2015-12-15
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 */
/**
 * @cond
 ***********************************************************************************************************************
 * FATFS v4.0.5 Helps the user to overwrite the provided ISR in system file
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-12-15:
 *     - Initial version<br>
 *
 * @endcond
 *
 */
#include "sltha.h"

#if (FATFS_STANDARDLIBRARY == 1)
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include <stdio.h>
/***********************************************************************************************************************
	* MACROS
 **********************************************************************************************************************/
/** File Handle array to store the file information  */
SLTHA_FILEHANDLE_t FileHandle[MAX_OPEN_FILES] = {{0}};

#if defined(__GNUC__) || defined(__TASKING__)

DWORD ErrorCodes[20] = {
		 SLTHA_SUCCESS,
		 (SLTHA_ERROR),  // FR_DISK_ERR,            /* (1) A hard error occurred in the low level disk I/O layer */
		 (SLTHA_ERROR),  // FR_INT_ERR,	            /* (2) Assertion failed */
		 EIO,            // FR_NOT_READY,           /* (3) The physical drive cannot work */
		 ENOENT,         // FR_NO_FILE,	            /* (4) Could not find the file */
		 ENOENT,         // FR_NO_PATH,	            /* (5) Could not find the path */
		 EINVAL,         // FR_INVALID_NAME,        /* (6) The path name format is invalid */
		 EACCES,         // FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
		 EEXIST,         // FR_EXIST,				/* (8) Access denied due to prohibited access */
		 EBADF,          // FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
		 EACCES,         // FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
		 ENODEV,         // FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
		 EIO,            // FR_NOT_ENABLED,			/* (12) The volume has no work area */
		 EIO,            // FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
		 (SLTHA_ERROR),  // FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
		 (SLTHA_ERROR),  // FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
		 (SLTHA_ERROR),  // FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
		 (SLTHA_ERROR),  // FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
		 (SLTHA_ERROR),  // FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_LOCK */
		 (SLTHA_ERROR)   // FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
};
#elif defined __CC_ARM
DWORD ErrorCodes[20] = { EINVAL };
#elif defined __ICCARM__
DWORD ErrorCodes[20] = {_LLIO_ERROR};
#endif
/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/
#if _FS_REENTRANT
/** Mutex Defined to protect the Slot Allocation Table in multi-task environment. */
osMutexDef(SlotHandle);
osMutexId SlotProtectionId;
#endif

#ifdef __CC_ARM
/** Standard IO device name defines. */
const char __stdin_name[]  = "STDIN";
const char __stdout_name[] = "STDOUT";
const char __stderr_name[] = "STDERR";
#endif
/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
static int  SLTHA_lFindAvailableSlot(int filedesc);
static time_t SLTHA_lTimeFormat(const FILINFO *fatfsinfoptr);

static void SLTHA_lFatInfoToStatus(struct stat *filestatusptr, const FILINFO *fatfsinfoptr);
#if !_FS_REENTRANT
static int SLTHA_lParamValidate(const char *path, int *flagptr,uint8_t *fatfsflagptr, int *slotnumptr);
#endif
#ifdef  __TASKING__
static _err_t SLTHA_lSetFlagsAccessModes(_open_flags_t *flagsptr, BYTE *fatfsflagptr);
#else
static int SLTHA_lSetFlagsAccessModes(int *flagsptr, BYTE *fatfsflagptr);
#endif

/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/*
 *  Function to Initialize all the local variables of Standard Librarry App
 */
void SLTHA_Init()
{
  int Slot;
/* Initialize Handle in the FileHandle Structure to -1*/
  for(Slot=0; Slot<MAX_OPEN_FILES; Slot++)
  {
    FileHandle[Slot].Fd = -1;
  }
/* Preserve the 0th, 1th and 2nd File Handles for Standard I/O and Error.*/
  FileHandle[0].Fd = STDIN_HANDLE;
  FileHandle[1].Fd = STDOUT_HANDLE;
  FileHandle[2].Fd = STDERR_HANDLE;
#if _FS_REENTRANT
  SlotProtectionId = osMutexCreate (osMutex(SlotHandle));
#endif
}

/*
 * Function to find whether the file is already opened and also assign a slot
 * for any new file to open.
 */
int SLTHA_lFindAvailableSlot(int FileDesc)
{
  static int Slot = 0;
  static int LastAllocFileHandle = -1;
  int LocalSlot = 0;
#if _FS_REENTRANT
  osStatus SemStatus;
  /* Slot allocation is protected by Mutex for re-entrancy */
  SemStatus = osMutexWait(SlotProtectionId,  osWaitForever);
  if (osOK == SemStatus)
  {
#endif
    /* Check if the File handle is the last allocated one */
    if( (FileDesc != -1)  && (FileDesc == LastAllocFileHandle))
    {
      /* Local copy of the allocated slot. */
      LocalSlot = Slot;
    }
    else
    {
      /* Check the FileHandle array to find the match for the File Handle*/
      for (Slot=0; Slot<MAX_OPEN_FILES; Slot++)
      {
        if (FileHandle[Slot].Fd == FileDesc)
        {
          if (FileDesc == SLTHA_EMPTY_SLOT)
          {
            /* Set the allocated slot value from free to allocated state so that
            the other tasks cannot use it.*/
            FileHandle[Slot].Fd = SLTHA_ALLOCATED_NOT_IN_USE;
          } /* End of "if (FileDesc == SLTHA_EMPTY_SLOT )"*/
          break;
        }/* End of  " if (FileHandle[Slot].Fd == FileDesc)"*/
      }
    }
      /* Local copy of the allocated slot. */
      LocalSlot = Slot;
      /* Save the last Allocated File Handle.*/
      LastAllocFileHandle = FileDesc;
#if _FS_REENTRANT
  }
  /* Release the mutex */
  if (SemStatus == osOK)
  {
    SemStatus =  osMutexRelease (SlotProtectionId);
  }
#endif

  return (LocalSlot);
}

#if _FS_MINIMIZE == 0
#if defined (__GNUC__) || defined ( __TASKING__)
/*
 * This function converts the time format
 */
static time_t SLTHA_lTimeFormat(const FILINFO *FatFsInfoPtr)
{
  struct tm TimeStruct;
  TimeStruct.tm_sec  = (FatFsInfoPtr->ftime & 0x001fUL) << 1UL;
  TimeStruct.tm_min  = (FatFsInfoPtr->ftime & 0x07e0UL) >> 5UL;
  TimeStruct.tm_hour = (FatFsInfoPtr->ftime & 0xf800UL) >> 11UL;
  TimeStruct.tm_mday = (FatFsInfoPtr->fdate & 0x001fUL);
  TimeStruct.tm_mon  = ((FatFsInfoPtr->fdate & 0x01e0UL) >> 5UL) - 1UL;
  TimeStruct.tm_year = ((FatFsInfoPtr->fdate & 0xfe00UL) >> 9UL) + 80UL;
  TimeStruct.tm_isdst = 0;
  return mktime(&TimeStruct);
}
#endif

/*
 *  Function to store the file information in the file status pointer
 */
#if defined (__GNUC__) || defined ( __TASKING__)
static void SLTHA_lFatInfoToStatus(struct stat *FileStatusPtr, const FILINFO *FatFsInfoPtr)
{
  memset(FileStatusPtr, 0, sizeof(stat));
  /*Populate the Argument Status Pointer with the Fat FS status Pointer*/
  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_DIR) ? S_IFDIR : S_IFREG;
#if defined (__GNUC__)
  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_RDO) ? ((S_IRWXU & ~S_IWUSR) |
                                                                (S_IRWXG & ~S_IWGRP) |
                                                                (S_IRWXO & ~S_IWOTH)) : (S_IRWXU | S_IRWXG | S_IRWXO);
#else
  FileStatusPtr->st_mode |= (FatFsInfoPtr->fattrib & AM_RDO) ?  (~_S_IWRITE) : (_S_IWRITE);
#endif
  FileStatusPtr->st_size = FatFsInfoPtr->fsize;
  FileStatusPtr->st_ctime = SLTHA_lTimeFormat(FatFsInfoPtr);
  FileStatusPtr->st_mtime = FileStatusPtr->st_ctime;
  FileStatusPtr->st_atime = FileStatusPtr->st_ctime;
#if defined (__GNUC__)
  FileStatusPtr->st_blksize = 512;
#endif
}
#endif
#endif

/*
 * This function set the file access modes.
 */
#ifdef  __TASKING__
  static _err_t SLTHA_lSetFlagsAccessModes(_open_flags_t *FlagsPtr, BYTE *FatFsFlagPtr)
#else
  static int SLTHA_lSetFlagsAccessModes(int *FlagsPtr, BYTE *FatFsFlagPtr)
#endif
{
  bool ReadOnlyFlag = false;
#ifdef  __TASKING__
  _err_t Status = SLTHA_SUCCESS;
#else
  int Status = SLTHA_SUCCESS;
#endif
#if defined(__GNUC__) || defined( __TASKING__) || defined(__ICCARM__ )
   /*  Append and Truncate flags cannot be set together */
  if (*FlagsPtr & SLTHA_APPEND)
  {
    *FlagsPtr &= ~SLTHA_TRUNC ;
  }
    /* Create & Truncate & Access mode is Write */
  if ( ((*FlagsPtr & (SLTHA_CREAT | SLTHA_TRUNC)) == (SLTHA_CREAT | SLTHA_TRUNC)) &&
                                                     (*FlagsPtr & (SLTHA_RDWR | SLTHA_WRONLY)))
  {
#if _FS_READONLY
    ReadOnlyFlag = true;
    Status = SLTHA_ERROR;
#else
    *FatFsFlagPtr = FA_CREATE_ALWAYS;
#endif
  }
  /* O_EXCL  When used with O_CREAT, if the file already exists it is an error
  *  and the open() will fail. */
  else if ((*FlagsPtr & (SLTHA_CREAT | SLTHA_EXCL)) == (SLTHA_CREAT | SLTHA_EXCL))
  {
    *FatFsFlagPtr = FA_OPEN_EXISTING;
  }
  /* Only create flag is set, opens the file if exist else creates a new file */
  else if ((*FlagsPtr & SLTHA_CREAT) == SLTHA_CREAT)
  {
#if _FS_READONLY
    ReadOnlyFlag = true;
    Status = SLTHA_ERROR;
#else
    *FatFsFlagPtr = FA_OPEN_ALWAYS;
#endif
  }
  /* Opens the file if any of the read, write or r/w flags are only set*/
  else if ((*FlagsPtr == SLTHA_RDONLY) || (*FlagsPtr == SLTHA_WRONLY) || (*FlagsPtr == SLTHA_RDWR))
  {
    *FatFsFlagPtr = FA_OPEN_EXISTING;
  }
  else
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EINVAL;
#elif defined( __ICCARM__)
    errno = _LLIO_ERROR;
#endif
    ReadOnlyFlag = true;
    Status = SLTHA_ERROR;
  }
#endif
  /* Check the access mode */
  if ( ReadOnlyFlag == false )
  {
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    if ((*FlagsPtr & SLTHA_RDWRMASK) == SLTHA_RDONLY)
#elif defined __CC_ARM
    if (*FlagsPtr &  SLTHA_RDONLY)
#endif
    {
      *FatFsFlagPtr |= FA_READ;
    }
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    else if ((*FlagsPtr & SLTHA_RDWRMASK) == SLTHA_WRONLY)
#elif defined __CC_ARM
    else if(*FlagsPtr &  SLTHA_WRONLY)
#endif
    {
#if _FS_READONLY
      Status = SLTHA_ERROR;
#else
      *FatFsFlagPtr |= FA_WRITE;
#endif
    }
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    else if ((*FlagsPtr & SLTHA_RDWRMASK) == SLTHA_RDWR)
#elif defined __CC_ARM
    else if (*FlagsPtr & SLTHA_RDWR)
#endif
    {
#if _FS_READONLY
      Status = SLTHA_ERROR;
#else
      *FatFsFlagPtr |= (FA_READ | FA_WRITE);
#endif
    }
    else
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#elif defined __CC_ARM
      errno = EINVAL;
#endif
      Status = (int)SLTHA_ERROR;
    }
  } /* End of " if ( ReadOnlyFlag == FALSE )"*/
  return (Status);
}

#if !_FS_REENTRANT
int SLTHA_lParamValidate(const char *Path, int *FlagPtr,uint8_t *FatFsFlagPtr, int *SlotNumPtr)
{
#ifdef  __TASKING__
  _err_t Status = SLTHA_ERROR;
#else
  int Status = (int)SLTHA_ERROR;
#endif
  int PathLen = 0;
  int SlotNumber;
  /*  Check free slot is available to open the file. If not then return error. */
  SlotNumber = SLTHA_lFindAvailableSlot(SLTHA_EMPTY_SLOT);
  if (SlotNumber == MAX_OPEN_FILES)
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = ENFILE;
#elif defined __CC_ARM
    errno =  EINVAL;
#elif defined  __ICCARM__
    errno = _LLIO_ERROR;
#endif
  }/* End of "if (SlotNumber == MAX_OPEN_FILES)"*/
  else
  {
    *SlotNumPtr = SlotNumber;
    /* Check the file path name should not exceed the maximum value*/
    PathLen = strlen(Path);
    if (!(PathLen > FILENAME_MAX ))
    {
      /* Check and Set Flags Accordingly */
      Status = SLTHA_lSetFlagsAccessModes(FlagPtr,FatFsFlagPtr);
      if( Status != SLTHA_SUCCESS)
      {
#if defined(__GNUC__) || defined( __TASKING__) || defined (__CC_ARM)
        errno = EINVAL;
#elif defined  __ICCARM__
        errno = _LLIO_ERROR;
#endif
      } /* End of "if ( Status != SLTHA_SUCCESS))"*/
      else
      {
        /* Allocate memory to store the file path name.*/
        FileHandle[SlotNumber].FilePath = (char *)malloc(PathLen+1);
        if( FileHandle[SlotNumber].FilePath  == NULL )
        {
          Status = (int)SLTHA_ERROR;
        }
        else
        {
          /* Store the file path name */
          strcpy(FileHandle[SlotNumber].FilePath ,Path);
#if defined(__GNUC__) || defined( __TASKING__)
          errno = EIO;
#elif defined __CC_ARM
          errno =  EINVAL;
#elif  __ICCARM__
          errno = _LLIO_ERROR;
#endif
          /* If File Pointer is NULL, then allocate the memory to open a file */
          if (FileHandle[SlotNumber].FatFsPtr == NULL)
          {
            FileHandle[SlotNumber].FatFsPtr = (FIL *)calloc(1, sizeof(FIL));
            if (FileHandle[SlotNumber].FatFsPtr == NULL)
            {
              Status = (int)SLTHA_ERROR;
            } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL))"*/
          } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL)"*/
        } /* End of "if( FileHandle[SlotNumber].FilePath  == NULL )"*/
      } /* End of "if( Status != SLTHA_SUCCESS)" */
    }/*End of " if (!(PathLen > FILENAME_MAX ))"*/
  } /* End of "if (SlotNumber == MAX_OPEN_FILES)"*/
  return (Status);
}

/**
 * @endcond
 */

/******************************************************************************
**                      Public Function Definitions                           **
*******************************************************************************/
/*
 * This function opens the file specified by the Path in the mode
 */
SLTHA_Open()
{
#ifdef  __TASKING__
  _err_t Status;
  _err_t FileDesc = -1;
#else
  int Status ;
  int FileDesc = -1;
#endif
  int  SlotNumber;
  uint8_t FatFsFlags = FA_OPEN_EXISTING;
  FRESULT Result;
  /* Find slot and validate the access modes.*/
  Status  = SLTHA_lParamValidate((const char *)Path, &Flags, &FatFsFlags, &SlotNumber);
  if (Status == SLTHA_SUCCESS)
  {
/* Call the f_open function */
    Result = f_open(FileHandle[SlotNumber].FatFsPtr,Path,FatFsFlags);
    if( Result != FR_OK)
    {
      errno = ErrorCodes[ Result];
    } /* End of "if( Result != FR_OK)"*/
    else
    {
      FileDesc = SlotNumber + MONITOR_FATFS;
      FileHandle[SlotNumber].Flags = Flags;
      FileHandle[SlotNumber].CurrentPos = 0;
      /* if Append flag set, Get the end position by using FatFS lseek function */
      if (Flags & SLTHA_APPEND)
      {
#if _FS_MINIMIZE == 3
        Result = FR_DENIED;
#else
        Result = f_lseek(FileHandle[SlotNumber].FatFsPtr, FileHandle[SlotNumber].FatFsPtr->fsize);
#endif
        if (Result != FR_OK)
        {
          FileDesc = -1;
        }/* End of "if( Result != FR_OK)"*/
        else
        {
          FileHandle[SlotNumber].CurrentPos = (int)FileHandle[SlotNumber].FatFsPtr->fptr;
        }
      } /* End of "if(Flags & SLTHA_APPEND)"*/
    }
  }
  /* Update the FD in the File Handle. */
  FileHandle[SlotNumber].Fd = FileDesc;
  Status = FileDesc;
/* Free the memory if File Handle is -1 and Valid FatFsPtr exists */
  if ((FileDesc < 0) &&  (FileHandle[SlotNumber].FatFsPtr != NULL))
  {
    free (FileHandle[SlotNumber].FilePath);
    free (FileHandle [SlotNumber].FatFsPtr);
    FileHandle[SlotNumber].FilePath = NULL;
    FileHandle[SlotNumber].FatFsPtr = NULL;
  } /* End of "if((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr )"*/
  return (Status);
}

/*
 * This function closes the file specified by the File descriptor.
 */
SLTHA_Close()
{
#ifdef  __TASKING__
  _err_t Status = SLTHA_ERROR;
#else
  int Status = (int)SLTHA_ERROR;
#endif
  int SlotNumber;
  FRESULT Result;
  do
  {
    /* Find the Slot number */
    SlotNumber = SLTHA_lFindAvailableSlot(Fd);
    if (SlotNumber == MAX_OPEN_FILES)
    {
#if defined(__GNUC__) || defined( __TASKING__)
      errno = EBADF;
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    }
/* Check FilePtr is not Null */
    if (FileHandle [SlotNumber].FatFsPtr != NULL)
    {
      Result = f_close (FileHandle[SlotNumber].FatFsPtr);
      /* Set the handle in the file info structure to -1 */
      free (FileHandle[SlotNumber].FilePath);
      free (FileHandle[SlotNumber].FatFsPtr);
      FileHandle[SlotNumber].FatFsPtr = NULL;
      if (Result != FR_OK)
      {
        errno = ErrorCodes[Result];
      }
      else
      {
        Status = SLTHA_SUCCESS;
      }
    }
    /* free the occupied slot */
    FileHandle[SlotNumber].Fd = -1;
  } while(0);
  return (Status);
}

/*
 * This function reads specified bytes of data from the file.
 */
SLTHA_Read()
{
  int SlotNumber;
  int BytesRead = 0;
  int BytesUnRead = -1;
  FRESULT Result;
  /* Find the Slot number occupied by the file to read from.*/
  SlotNumber = SLTHA_lFindAvailableSlot(Fd);
/* Check If write only flag is set  or Max Files are opened.*/
  if ( (SlotNumber == MAX_OPEN_FILES) || ((FileHandle[SlotNumber].Flags & SLTHA_WRONLY) != 0))
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EBADF;
#elif defined __CC_ARM
    errno = EINVAL;
#elif defined __ICCARM__
    errno = _LLIO_ERROR;
#endif
    BytesRead = -1;
  }
  else
  {
/* Switch as per the file descriptor.*/
    switch(Fd)
    {
      case STDIN_HANDLE:
           break;

      case STDOUT_HANDLE:
             break;

      case STDERR_HANDLE:
             break;

      default:
         if (FileHandle[SlotNumber].FatFsPtr != NULL)
         {
           /* Call the Fat FS f_read function */
           Result = f_read(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length, (UINT *)&BytesRead);
           if (Result != FR_OK)
           {
             errno = ErrorCodes[ Result];
             BytesRead = -1;
           }
           else
           {
             BytesUnRead = (int)Length - BytesRead;
           }
         }/*End of "if (FileHandle[SlotNumber].FatFsPtr != NULL)"*/
         break;
      }
    if (BytesUnRead < 0)
    {
      BytesRead = -1;
    }
    else
    {
      FileHandle[SlotNumber].CurrentPos += ((int)Length - BytesUnRead);
    }
  }
  return (BytesRead);
}

/*
 * This function writes Length bytes of data into the file specified.
 */
SLTHA_Write()
{
  int SlotNumber;
  int BytesWritten = 0;
  int BytesUnWritten = -1;
#if (_FS_READONLY == 0)
  FRESULT Result;
#endif
  /* Find the Slot number occupied by the file to read from.*/
  SlotNumber = SLTHA_lFindAvailableSlot(Fd);
  /* Check If read only flag is set or Max Files are opened. */
  if ( (SlotNumber == MAX_OPEN_FILES) || ((FileHandle[SlotNumber].Flags & SLTHA_RDONLY ) == 1))
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EBADF;
#elif defined  __CC_ARM
    errno = EINVAL;
#elif defined  __ICCARM__
    errno = _LLIO_ERROR;
#endif
  }
  else
  {
/* Switch as per the file descriptor.*/
    switch(Fd)
    {
      case STDIN_HANDLE:
           break;

      case STDOUT_HANDLE:
           break;

      case STDERR_HANDLE:
           break;
      default:
#if _FS_READONLY
        break;
#else
        if (FileHandle[SlotNumber].FatFsPtr != NULL)
        {
          /* Call the Fat FS f_write function */
          Result = f_write(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length, (UINT *)&BytesWritten);
          if (Result != FR_OK)
          {
            errno = ErrorCodes[Result];
          }
          else
          {
            BytesUnWritten = (int)Length - BytesWritten;
          }
        }
        break;
#endif
    } /* End of "switch case "*/
  }
  if((BytesUnWritten  == -1) || (BytesUnWritten == (int)Length))
  {
    BytesWritten = -1;
  }
  else
  {
    FileHandle[SlotNumber].CurrentPos += ((int)Length - BytesUnWritten);
  }
  return (BytesWritten);
}

/*
 * This function Move file pointer of a file object specified by the
 * File Descriptor.
 */
SLTHA_Lseek()
{
  int FileOffset = -1;
#if (_FS_MINIMIZE != 3)
  int SlotNumber;
  FRESULT Result;
#endif

#if (_FS_MINIMIZE != 3 )
  /* Find the Slot number occupied by the file to read from.*/
  SlotNumber = SLTHA_lFindAvailableSlot(Fd);
  if ( (SlotNumber == MAX_OPEN_FILES) ||  (FileHandle[SlotNumber].FatFsPtr == NULL))
  {
#if defined(__GNUC__) || defined( __TASKING__)
    errno = EBADF;
#elif defined __CC_ARM
    errno = EINVAL;
#elif defined  __ICCARM__
    errno = _LLIO_ERROR;
#endif
  }
  else
  {
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    /* Check Direction Mode */
    if (DirMode == SEEK_SET)
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, Offset);
    }
    else if (DirMode == SEEK_CUR)
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, FileHandle [SlotNumber].FatFsPtr->fptr + Offset);
    }
    else if (DirMode == SEEK_END)
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, FileHandle [SlotNumber].FatFsPtr->fsize + Offset);
    }
    else
    {
      Result = FR_INVALID_PARAMETER ;
    }
#elif __CC_ARM
    Result= f_lseek (FileHandle[SlotNumber].FatFsPtr,Offset);
#endif
    /* If Fat FS Function call returns Error*/
    if (Result != FR_OK)
    {
      errno = ErrorCodes[Result];
    }
    else
    {
      FileHandle[SlotNumber].CurrentPos = (int)FileHandle [SlotNumber].FatFsPtr->fptr;
      FileOffset = FileHandle[SlotNumber].CurrentPos;
    }
  }
#endif
  return (FileOffset);
}

/*
 * This function Delete an existing file or directory.
 */
SLTHA_Remove()
{
  int Status = (int)SLTHA_ERROR;
#if ((_FS_READONLY == 0) && ( _FS_MINIMIZE == 0))
  FRESULT Result;
#endif
  do
  {
#if ((_FS_READONLY != 0) || ( _FS_MINIMIZE != 0))
    break;
#else
    /* Call the Fat FS unlink function */
    Result = f_unlink (Path);
    if( Result != FR_OK)
    {
      errno = ErrorCodes[Result];
      break;
    }
    Status = SLTHA_SUCCESS;
#endif
  } while(0);
  return (Status);
}

/*
 * This function gets file status on basis of file descriptor passed.
 */

#if defined  (__GNUC__) || defined (  __TASKING__)
SLTHA_FileStatus()
{
  int Status = SLTHA_ERROR;
#if _FS_MINIMIZE == 0
  FILINFO FatFsInfoStruct = {0};
  FRESULT Result;
  int SlotNumber;
  do
  {
    if( ( Fd >= STDIN_HANDLE ) && ( Fd <= STDERR_HANDLE ) )
    {
      FileStatusPtr->st_mode = S_IFCHR;
      Status = SLTHA_SUCCESS;
      break;
    }
    /* Find the Slot number occupied by the file to read the status*/
    SlotNumber = SLTHA_lFindAvailableSlot(Fd);
    /* Call the Fat FS Status function */
    Result = f_stat(FileHandle[SlotNumber].FilePath, &FatFsInfoStruct);
    if (Result != FR_OK)
    {
      errno = ErrorCodes[Result];
    }
    else
    {
      SLTHA_lFatInfoToStatus(FileStatusPtr,(const FILINFO*)&FatFsInfoStruct);
      Status = SLTHA_SUCCESS;
    }
  } while(0);
#endif
  return (Status);
}

/*
 * This function gets file status on basis of file path
 */
SLTHA_Status()
{
  int Status = SLTHA_ERROR;
#if _FS_MINIMIZE == 0
  FILINFO FatFsInfoStruct = {0};
  FRESULT Result;
  do
  {
    /* Call the Fat FS Status function */
    Result = f_stat (Path, &FatFsInfoStruct);
    if( Result != FR_OK)
    {
      errno = ErrorCodes[Result];
      break;
    }
    SLTHA_lFatInfoToStatus(FileStatusPtr,(const FILINFO*)&FatFsInfoStruct);
    Status = SLTHA_SUCCESS;
  } while(0);
#endif
  return (Status);
}
#endif

/*
 * This function rename/move a file or directory.
 */
SLTHA_Rename()
{
#if ((_FS_READONLY == 0) && ( _FS_MINIMIZE == 0))
  FRESULT Result;
#endif
  int Status = (int)SLTHA_ERROR;
  do
  {
#if ((_FS_READONLY != 0) || ( _FS_MINIMIZE != 0))
    break;
#else
    /* Call the Fat FS Status function */
    Result = f_rename(Oldpath, Newpath);
    if(Result != FR_OK)
    {
      errno = ErrorCodes[Result];
    }
    else
    {
      Status = SLTHA_SUCCESS;
    }
#endif
  } while(0);
  return (Status);
}
#else
/*
 * This function opens the file specified by the Path in the mode
 */
SLTHA_Open()
{
#ifdef  __TASKING__
  _err_t Status = SLTHA_ERROR;
  _err_t FileDesc = -1;
#else
  int Status = SLTHA_ERROR;
  int FileDesc = -1;
#endif
  int  SlotNumber;
  uint32_t PathLen = 0;
  BYTE FatFsFlags = FA_OPEN_EXISTING;
  FRESULT Result;
  do
  {
/*  Check free slot is available to open the file. If not then return error. */
    SlotNumber = SLTHA_lFindAvailableSlot(SLTHA_EMPTY_SLOT);
    if (SlotNumber == MAX_OPEN_FILES)
    {
#if ((defined(__GNUC__) || defined( __TASKING__)) && _FS_REENTRANT)
      ReentPtr->_errno = ENFILE;
#elif defined __CC_ARM
      errno =  EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    }/* End of "if (SlotNumber == MAX_OPEN_FILES)"*/
    /* Check the file path name should not exceed the maximum value*/
    PathLen = strlen(Path);
    if (PathLen > FILENAME_MAX)
    {
      break;
    }
/* Check and Set Flags Accordingly */
    Status = SLTHA_lSetFlagsAccessModes(&Flags,&FatFsFlags);
    if( Status != SLTHA_SUCCESS)
    {
#if defined(__GNUC__) || defined( __TASKING__) || defined (__CC_ARM)
      ReentPtr->_errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    } /* End of "if ( Status != SLTHA_SUCCESS))"*/
    /* Allocate memory to store the file path name.*/
    FileHandle[SlotNumber].FilePath = (char *)malloc(PathLen+1);
    if( FileHandle[SlotNumber].FilePath  == NULL )
    {
      break;
    }
    /* Store the file path name */
    strcpy(FileHandle[SlotNumber].FilePath ,Path);
#if defined(__GNUC__) || defined( __TASKING__)
    ReentPtr->_errno = EIO;
#elif defined __CC_ARM
    errno =  EINVAL;
#elif  __ICCARM__
    errno = _LLIO_ERROR;
#endif
    /* If File Pointer is NULL, then allocate the memory to open a file  */
    if (FileHandle[SlotNumber].FatFsPtr == NULL)
    {
      FileHandle[SlotNumber].FatFsPtr = (FIL *)calloc(1, sizeof(FIL));
      if (FileHandle[SlotNumber].FatFsPtr == NULL)
      {
        Status = SLTHA_ERROR;
        break;
      } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL))"*/
    } /* End of "if (FileHandle[SlotNumber].FatFsPtr == NULL)"*/
    /* Call the f_open function */
    Result = f_open(FileHandle[SlotNumber].FatFsPtr,Path,FatFsFlags);
    if( Result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[ Result];
      break;
    } /* End of "if( Result != FR_OK)"*/
    FileDesc = SlotNumber + MONITOR_FATFS;
    FileHandle[SlotNumber].Flags = Flags;
    FileHandle[SlotNumber].CurrentPos = 0;
    /* if Append flag set, Get the end position by using FatFS lseek function */
    if (Flags & SLTHA_APPEND)
    {
#if _FS_MINIMIZE == 3
      Result = FR_DENIED;
#else
      Result = f_lseek(FileHandle[SlotNumber].FatFsPtr, FileHandle[SlotNumber].FatFsPtr->fsize);
#endif
      if (Result != FR_OK)
      {
        FileDesc = -1;
        break;
      }/* End of "if( Result != FR_OK)"*/
      FileHandle[SlotNumber].CurrentPos = FileHandle[SlotNumber].FatFsPtr->fptr;
    } /* End of "if(Flags & SLTHA_APPEND)"*/
  } while(0);
  /* Update the Fd in the File Handle. */
  FileHandle[SlotNumber].Fd = FileDesc;
  Status = FileDesc;
/* Free the memory if File Handle is -1 and Valid FatFsPtr exists */
  if ((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr)
  {
    free (FileHandle[SlotNumber].FilePath);
    free (FileHandle [SlotNumber].FatFsPtr);
    FileHandle[SlotNumber].FilePath = NULL;
    FileHandle[SlotNumber].FatFsPtr = NULL;
  } /* End of "if((FileDesc < 0) &&  FileHandle[SlotNumber].FatFsPtr )"*/
  return (Status);
}

/*
 * This function closes the file specified by the File descriptor.
 */
SLTHA_Close()
{
#ifdef  __TASKING__
  _err_t Status = SLTHA_ERROR;
#else
  int Status = SLTHA_ERROR;
#endif
  int SlotNumber;
  FRESULT Result;
    /* Find the Slot number */
    SlotNumber = SLTHA_lFindAvailableSlot(Fd);
    if (SlotNumber == MAX_OPEN_FILES)
    {
#if defined(__GNUC__) || defined( __TASKING__)
      ReentPtr->_errno = EBADF;
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
    }
    else
    {
      /* Check FilePtr is not Null */
      if (FileHandle [SlotNumber].FatFsPtr != NULL)
      {
        Result = f_close (FileHandle[SlotNumber].FatFsPtr);
        /* Set the handle in the file info structure to -1 */
        free (FileHandle[SlotNumber].FilePath);
        free (FileHandle[SlotNumber].FatFsPtr);
        FileHandle[SlotNumber].FatFsPtr = NULL;
        if (Result != FR_OK)
        {
          ReentPtr->_errno = ErrorCodes[ Result];
        }
        Status = SLTHA_SUCCESS;
      }
    }
    /* free the occupied slot */
    FileHandle[SlotNumber].Fd = -1;

  return (Status);
}

/*
 * This function reads specified bytes of data from the file.
 */
SLTHA_Read()
{
  int SlotNumber;
  int BytesRead = 0;
  int BytesUnRead = -1;
  FRESULT Result;
    /* Find the Slot number occupied by the file to read from.*/
    SlotNumber = SLTHA_lFindAvailableSlot(Fd);
/* Check If write only flag is set  or Max Files are opened.*/
    if ( (SlotNumber == MAX_OPEN_FILES) || ((FileHandle[SlotNumber].Flags & SLTHA_WRONLY) != 0UL))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      ReentPtr->_errno = EBADF;
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined __ICCARM__
      errno = _LLIO_ERROR;
#endif
      BytesRead = -1;
   }
   else
   {
    /* Switch as per the file descriptor.*/
    switch(Fd)
    {
     case STDIN_HANDLE:
          break;

     case STDOUT_HANDLE:
           break;

     case STDERR_HANDLE:
           break;

     default:
       if (FileHandle[SlotNumber].FatFsPtr != NULL)
       {
/* Call the Fat FS f_read function */
         Result = f_read(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length, (UINT *)&BytesRead);
         if (Result != FR_OK)
         {
           ReentPtr->_errno = ErrorCodes[Result];
           BytesRead = -1;
           break;
         }
         BytesUnRead = Length - BytesRead;
       }
       break;
    }
    if (BytesUnRead < 0)
    {
      BytesRead = -1;
    }
    FileHandle[SlotNumber].CurrentPos += (Length - BytesUnRead);
  }
  return (BytesRead);
}

/*
 * This function writes Length bytes of data into the file specified.
 */
SLTHA_Write()
{
  int SlotNumber;
  int BytesWritten = 0;
  int BytesUnWritten = -1;
#if !_FS_READONLY
  FRESULT Result;
#endif
  do
  {
    /* Find the Slot number occupied by the file to read from.*/
    SlotNumber = SLTHA_lFindAvailableSlot(Fd);
    /* Check If read only flag is set or Max Files are opened. */
    if ( (SlotNumber == MAX_OPEN_FILES) || ((FileHandle[SlotNumber].Flags & SLTHA_RDONLY ) == 1UL))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      ReentPtr->_errno = EBADF;
#elif defined  __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    }
/* Switch as per the file descriptor.*/
    switch(Fd)
    {
      case STDIN_HANDLE:
           break;

      case STDOUT_HANDLE:
           break;

      case STDERR_HANDLE:
           break;

      default:
#if _FS_READONLY
    break;
#else
        if (FileHandle[SlotNumber].FatFsPtr != NULL)
        {
          /* Call the Fat FS f_write function */
          Result = f_write(FileHandle [SlotNumber].FatFsPtr, BufferPtr, Length, (UINT *)&BytesWritten);
          if (Result != FR_OK)
          {
            ReentPtr->_errno = ErrorCodes[Result];
            break;
          }
          BytesUnWritten = Length - BytesWritten;
        }
        break;
#endif
    } /* End of "switch case "*/
  } while(0);
  if((BytesUnWritten  == -1) || (BytesUnWritten == Length))
  {
    BytesWritten = -1;
  }
  else
  {
    FileHandle[SlotNumber].CurrentPos += (Length - BytesUnWritten);
  }
  return (BytesWritten);
}

/*
 * This function Move file pointer of a file object specified by the
 * File Descriptor.
 */
SLTHA_Lseek()
{
  int FileOffset = -1;
#if _FS_MINIMIZE != 3
  int SlotNumber;
  FRESULT Result;
#endif
  do
  {
#if _FS_MINIMIZE == 3
    break;
#else
    /* Find the Slot number occupied by the file to read from.*/
    SlotNumber = SLTHA_lFindAvailableSlot(Fd);
    if ( (SlotNumber == MAX_OPEN_FILES) ||  (FileHandle[SlotNumber].FatFsPtr == NULL))
    {
#if defined(__GNUC__) || defined( __TASKING__)
      ReentPtr->_errno = EBADF;
#elif defined __CC_ARM
      errno = EINVAL;
#elif defined  __ICCARM__
      errno = _LLIO_ERROR;
#endif
      break;
    }
#if defined(__GNUC__) || defined( __TASKING__) || defined( __ICCARM__ )
    /* Check Direction Mode */
    if (DirMode == SEEK_SET)
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, Offset);
    }
    else if (DirMode == SEEK_CUR)
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, FileHandle [SlotNumber].FatFsPtr->fptr + Offset);
    }
    else if (DirMode == SEEK_END)
    {
      Result = f_lseek (FileHandle[SlotNumber].FatFsPtr, FileHandle [SlotNumber].FatFsPtr->fsize + Offset);
    }
    else
      break;
#elif __CC_ARM
    Result= f_lseek (FileHandle[SlotNumber].FatFsPtr,Offset);
#endif
    /* If Fat FS Function call returns Error*/
    if (Result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[Result];
      break;
    }
    FileHandle[SlotNumber].CurrentPos = FileHandle [SlotNumber].FatFsPtr->fptr;
    FileOffset = FileHandle[SlotNumber].CurrentPos;
#endif
  } while(0);
  return (FileOffset);
}

/*
 * This function Delete an existing file or directory.
 */
SLTHA_Remove()
{
  int Status = SLTHA_ERROR;
#if ((!_FS_READONLY ) && (_FS_MINIMIZE == 0))
  FRESULT Result;
#endif
  do
  {
#if ((_FS_READONLY) || (_FS_MINIMIZE != 0))
    break;
#else
    /* Call the Fat FS unlink function */
    Result = f_unlink(Path);
    if( Result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[Result];
      break;
    }
    Status = SLTHA_SUCCESS;
#endif
  } while(0);
  return (Status);
}

/*
 * This function gets file status on basis of file descriptor passed.
 */
#if defined  (__GNUC__) || defined ( __TASKING__)
SLTHA_FileStatus()
{
  int Status = SLTHA_ERROR;
#if _FS_MINIMIZE == 0
  FILINFO FatFsInfoStruct = {0};
  FRESULT Result;
  int SlotNumber;
  do
  {
    if( ( Fd >= STDIN_HANDLE ) && ( Fd <= STDERR_HANDLE ) )
    {
      FileStatusPtr->st_mode = S_IFCHR;
      return 0;
    }
    /* Find the Slot number occupied by the file to read the status*/
    SlotNumber = SLTHA_lFindAvailableSlot(Fd);
    /* Call the Fat FS Status function */
    Result = f_stat(FileHandle[SlotNumber].FilePath, &FatFsInfoStruct);
    if (Result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[Result];
      break;
    }
    SLTHA_lFatInfoToStatus(FileStatusPtr,&FatFsInfoStruct);
    Status = SLTHA_SUCCESS;
  } while(0);
#endif
  return (Status);
}
/*
 * This function gets file status on basis of file path
 */
SLTHA_Status()
{
  int Status = SLTHA_ERROR;
#if _FS_MINIMIZE == 0
  FILINFO FatFsInfoStruct = {0};
  FRESULT Result;
  do
  {
    /* Call the Fat FS Status function */
    Result = f_stat (Path, &FatFsInfoStruct);
    if( Result != FR_OK)
    {
      ReentPtr->_errno = ErrorCodes[Result];
      break;
    }
    SLTHA_lFatInfoToStatus(FileStatusPtr,&FatFsInfoStruct);
    Status = SLTHA_SUCCESS;
  } while(0);
#endif
  return (Status);
}
#endif
#endif


/*
 * This function queries whether output stream is a terminal.
 */
#if defined(__GNUC__)  || defined (__CC_ARM)
SLTHA_IsAtty()
{
  return (Fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */
}
#endif

#if defined(__GNUC__)
/* This function establish a new name for an existing file. This function is
 * not supported by Fat File system.
 */
int _link (char *OldName, char *NewName)
{
  errno = EMLINK;
  return -1;
}
#endif

/*
 * IAR internally calls __dwrite for write system call .
 */
#if defined ( __ICCARM__)
size_t __dwrite(int Fd,const unsigned char *BufferPtr, size_t Length)
{
  return  __write(Fd,BufferPtr,Length);
}
#endif

/*
 * Keil compiler searches for the following system calls while retargetting is
 * done.
 */
#if defined (__CC_ARM)
void _ttywrch (int ch)
{

}

int _sys_ensure (FILEHANDLE Fh)
{
  Fh = Fh;
  return (0);
}

long _sys_flen (FILEHANDLE Fh)
{
  Fh = Fh;
  return (0);
}

int _sys_tmpnam (char *Name, int Sig, unsigned Maxlen)
{
  *Name = *Name;
  Sig = Sig;
  Maxlen = Maxlen;
  return (0);
}

char *_sys_command_string (char *Cmd, int Len)
{
  *Cmd = *Cmd;
  Len = Len;
  return (0);
}

void _sys_exit (int return_code)
{
  /* Endless loop. */
  do{
  }while (1);
}

#endif

#endif

